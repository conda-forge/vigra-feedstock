From 142b12c549615c4e2798c85a187af17c7e2a182f Mon Sep 17 00:00:00 2001
From: Mark Harfouche <mark.harfouche@gmail.com>
Date: Mon, 5 Sep 2022 15:26:03 -0400
Subject: [PATCH] Avoid use of deprecated libtiff types

---
 include/vigra/multi_array_chunked.hxx |  10 +--
 include/vigra/tiff.hxx                | 102 +++++++++++++-------------
 src/impex/tiff.cxx                    |  28 +++----
 test/impex/test.cxx                   |   4 +-
 4 files changed, 72 insertions(+), 72 deletions(-)

diff --git a/include/vigra/multi_array_chunked.hxx b/include/vigra/multi_array_chunked.hxx
index dd8c7f666..e9c7cd200 100644
--- a/include/vigra/multi_array_chunked.hxx
+++ b/include/vigra/multi_array_chunked.hxx
@@ -39,7 +39,7 @@
     image size: 200^3, chunk size: 64^3, i.e. chunk count: 4^3
     times in msec, excluding time to store file on disk
 
-    win64/vs2012 (koethe-laptop):            uint8     float    double
+    win64/vs2012 (koethe-laptop):          uint8_t     float    double
     plain array                                 18        18        18
     chunked array (all in cache)                25        26        26
     thread-safe chunked (all in cache)          27        28        29
@@ -47,7 +47,7 @@
     thread-safe chunked (1 row in cache)        45        48        52
     chunked (initial creation, all in cache)    33        43        57
 
-    linux/gcc 4.7.3 (birdofprey):            uint8     float    double
+    linux/gcc 4.7.3 (birdofprey):          uint8_t     float    double
     plain array                                 16        20        21
     chunked array (all in cache)                17        23        24
     thread-safe chunked (all in cache)          19        24        25
@@ -55,7 +55,7 @@
     thread-safe chunked (1 row in cache)        24        33        39
     chunked (initial creation, all in cache)    22        34        48
 
-    OS X 10.7:                               uint8     float    double
+    OS X 10.7:                             uint8_t     float    double
     plain array                                 11        22        24
     chunked array (all in cache)                --        --        --
     thread-safe chunked (all in cache)          20        25        26
@@ -71,7 +71,7 @@
     image size: 400^3, chunk size: 127^3, i.e. chunk count: 4^3
     times in msec, excluding time to store file on disk
 
-    win64/vs2012 (koethe-laptop):            uint8     float    double
+    win64/vs2012 (koethe-laptop):          uint8_t     float    double
     plain array                                130       130       130
     chunked array (all in cache)               190       190       200
     thread-safe chunked (all in cache)         190       200       210
@@ -79,7 +79,7 @@
     thread-safe chunked (1 row in cache)       240       270       300
     chunked (initial creation, all in cache)   230       300       400
 
-    linux/gcc 4.7.3 (birdofprey):            uint8     float    double
+    linux/gcc 4.7.3 (birdofprey):          uint8_t     float    double
     plain array                                130       162       165
     chunked array (all in cache)               131       180       184
     thread-safe chunked (all in cache)         135       183       188
diff --git a/include/vigra/tiff.hxx b/include/vigra/tiff.hxx
index 73991892f..9133b268c 100644
--- a/include/vigra/tiff.hxx
+++ b/include/vigra/tiff.hxx
@@ -116,7 +116,7 @@ typedef TIFF TiffImage;
     Namespace: vigra
     
     \code
-    uint32 w, h;
+    uint32_t w, h;
     TiffImage * tiff = TIFFOpen("tiffimage.tiff", "r");
     TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
     TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);
@@ -224,8 +224,8 @@ importTiffImage(TiffImage * tiff, ImageIterator iter, Accessor a, VigraFalseType
     Namespace: vigra
 
     \code
-    uint32 w, h;
-    uint16 photometric;
+    uint32_t w, h;
+    uint16_t photometric;
     TiffImage * tiff = TIFFOpen("tiffimage.tiff", "r");
     TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
     TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);
@@ -246,8 +246,8 @@ importTiffImage(TiffImage * tiff, ImageIterator iter, Accessor a, VigraFalseType
 
     \deprecatedUsage{tiffToScalarImage}
     \code
-    uint32 w, h;
-    uint16 photometric;
+    uint32_t w, h;
+    uint16_t photometric;
     
     TiffImage * tiff = TIFFOpen("tiffimage.tiff", "r");
     TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
@@ -282,7 +282,7 @@ importTiffImage(TiffImage * tiff, ImageIterator iter, Accessor a, VigraFalseType
     The output array must have the correct shape.
     
     \code
-    uint16 sampleFormat, samplesPerPixel, bitsPerSample, photometric;
+    uint16_t sampleFormat, samplesPerPixel, bitsPerSample, photometric;
            
     TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat);
     TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);
@@ -309,9 +309,9 @@ tiffToScalarImage(TiffImage * tiff, ImageIterator iter, Accessor a)
              "tiffToScalarImage(TiffImage *, ScalarImageIterator): " 
              "NULL pointer to input data.");
     
-    uint16 sampleFormat = 1, bitsPerSample, 
-           fillorder, samplesPerPixel, photometric;
-    uint32 w,h;
+    uint16_t sampleFormat = 1, bitsPerSample, 
+             fillorder, samplesPerPixel, photometric;
+    uint32_t w,h;
     
     TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat);
     TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);
@@ -373,11 +373,11 @@ tiffToScalarImage(TiffImage * tiff, ImageIterator iter, Accessor a)
                     {
                         if(fillorder == FILLORDER_MSB2LSB)
                         {
-                            a.set(((((uint8 *)buf)[x/8] >> (7 - x%8)) & 1) ? max : min, xd);
+                            a.set(((((uint8_t *)buf)[x/8] >> (7 - x%8)) & 1) ? max : min, xd);
                         }
                         else
                         {
-                            a.set(((((uint8 *)buf)[x/8] >> (x%8)) & 1) ? max : min, xd);
+                            a.set(((((uint8_t *)buf)[x/8] >> (x%8)) & 1) ? max : min, xd);
                         }
                     }
                 }
@@ -392,7 +392,7 @@ tiffToScalarImage(TiffImage * tiff, ImageIterator iter, Accessor a)
 
                     for(unsigned int x=0; x<w; ++x, ++xd.x)
                     {
-                        a.set(offset + scale*((uint8 *)buf)[x], xd);
+                        a.set(offset + scale*((uint8_t *)buf)[x], xd);
                     }
                 }
                 break;
@@ -406,7 +406,7 @@ tiffToScalarImage(TiffImage * tiff, ImageIterator iter, Accessor a)
 
                     for(unsigned int x=0; x<w; ++x, ++xd.x)
                     {
-                        a.set(((uint16 *)buf)[x], xd);
+                        a.set(((uint16_t *)buf)[x], xd);
                     }
                 }
                 break;
@@ -420,7 +420,7 @@ tiffToScalarImage(TiffImage * tiff, ImageIterator iter, Accessor a)
 
                     for(unsigned int x=0; x<w; ++x, ++xd.x)
                     {
-                        a.set(((uint32 *)buf)[x], xd);
+                        a.set(((uint32_t *)buf)[x], xd);
                     }
                 }
                 break;
@@ -465,7 +465,7 @@ tiffToScalarImage(TiffImage * tiff, ImageIterator iter, Accessor a)
 
                     for(unsigned int x=0; x<w; ++x, ++xd.x)
                     {
-                        a.set(offset + scale*((uint8 *)buf)[x], xd);
+                        a.set(offset + scale*((uint8_t *)buf)[x], xd);
                     }
                 }
                 break;
@@ -613,8 +613,8 @@ tiffToScalarImage(TiffImage * tiff, pair<ImageIterator, Accessor> dest)
     Namespace: vigra
 
     \code
-    uint32 w, h;
-    uint16 photometric
+    uint32_t w, h;
+    uint16_t photometric
     TiffImage * tiff = TIFFOpen("tiffimage.tiff", "r");
     TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
     TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);
@@ -635,8 +635,8 @@ tiffToScalarImage(TiffImage * tiff, pair<ImageIterator, Accessor> dest)
 
     \deprecatedUsage{tiffToRGBImage}
     \code
-    uint32 w, h;
-    uint16 photometric
+    uint32_t w, h;
+    uint16_t photometric
     TiffImage * tiff = TIFFOpen("tiffimage.tiff", "r");
     TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
     TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);
@@ -672,7 +672,7 @@ tiffToScalarImage(TiffImage * tiff, pair<ImageIterator, Accessor> dest)
     The destination image must have the appropriate size.
     
     \code
-    uint16 sampleFormat, samplesPerPixel, bitsPerSample, photometric;
+    uint16_t sampleFormat, samplesPerPixel, bitsPerSample, photometric;
            
     TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat);
     TIFFGetField(tiff, TIFFTAG_SAMPLESPERPIXEL, &samplesPerPixel);
@@ -700,9 +700,9 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
               "tiffToRGBImage(TiffImage *, RGBImageIterator): " 
           "NULL pointer to input data.");
     
-    uint16 sampleFormat = 1, bitsPerSample, 
-           samplesPerPixel, planarConfig, photometric;
-    uint32 w,h;
+    uint16_t sampleFormat = 1, bitsPerSample, 
+             samplesPerPixel, planarConfig, photometric;
+    uint32_t w,h;
     
     TIFFGetField(tiff, TIFFTAG_SAMPLEFORMAT, &sampleFormat);
     TIFFGetField(tiff, TIFFTAG_BITSPERSAMPLE, &bitsPerSample);
@@ -727,7 +727,7 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
     {
       case PHOTOMETRIC_PALETTE:
       {
-        uint32 * raster = new uint32[w*h];
+        uint32_t * raster = new uint32_t[w*h];
         try
         {
             if (!TIFFReadRGBAImage(tiff, w, h, raster, 0)) 
@@ -743,7 +743,7 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                 typename RGBImageIterator::row_iterator rowend = rowit + w;
                 for(int x=0; rowit<rowend; ++rowit,++x )
                 {
-                    uint32 rast = raster[x+y*w];
+                    uint32_t rast = raster[x+y*w];
                     a.setRGB(TIFFGetR(rast),TIFFGetG(rast),TIFFGetB(rast),rowit);
                 }
             }
@@ -781,12 +781,12 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                   {
                     for(unsigned int y=0; y<h; ++y, ++yd.y)
                     {
-                        uint8 *pr, *pg, *pb;
+                        uint8_t *pr, *pg, *pb;
                         
                         if(planarConfig == PLANARCONFIG_CONTIG)
                         {
                             TIFFReadScanline(tiff, bufr, y);
-                            pr = (uint8 *)bufr;
+                            pr = (uint8_t *)bufr;
                             pg = pr+1;
                             pb = pg+1;
                         }
@@ -795,9 +795,9 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                             TIFFReadScanline(tiff, bufr, y, 0);
                             TIFFReadScanline(tiff, bufg, y, 1);
                             TIFFReadScanline(tiff, bufb, y, 2);
-                            pr = (uint8 *)bufr;
-                            pg = (uint8 *)bufg;
-                            pb = (uint8 *)bufb;
+                            pr = (uint8_t *)bufr;
+                            pg = (uint8_t *)bufg;
+                            pb = (uint8_t *)bufb;
                         }
                         
                         typename RGBImageIterator::row_iterator rowit = yd.rowIterator();
@@ -811,12 +811,12 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                   {
                     for(unsigned int y=0; y<h; ++y, ++yd.y)
                     {
-                        uint16 *pr, *pg, *pb;
+                        uint16_t *pr, *pg, *pb;
                         
                         if(planarConfig == PLANARCONFIG_CONTIG)
                         {
                             TIFFReadScanline(tiff, bufr, y);
-                            pr = (uint16 *)bufr;
+                            pr = (uint16_t *)bufr;
                             pg = pr+1;
                             pb = pg+1;
                         }
@@ -825,9 +825,9 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                             TIFFReadScanline(tiff, bufr, y, 0);
                             TIFFReadScanline(tiff, bufg, y, 1);
                             TIFFReadScanline(tiff, bufb, y, 2);
-                            pr = (uint16 *)bufr;
-                            pg = (uint16 *)bufg;
-                            pb = (uint16 *)bufb;
+                            pr = (uint16_t *)bufr;
+                            pg = (uint16_t *)bufg;
+                            pb = (uint16_t *)bufb;
                         }
                         
                         typename RGBImageIterator::row_iterator rowit = yd.rowIterator();
@@ -841,12 +841,12 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                   {
                     for(unsigned int y=0; y<h; ++y, ++yd.y)
                     {
-                        uint32 *pr, *pg, *pb;
+                        uint32_t *pr, *pg, *pb;
                         
                         if(planarConfig == PLANARCONFIG_CONTIG)
                         {
                             TIFFReadScanline(tiff, bufr, y);
-                            pr = (uint32 *)bufr;
+                            pr = (uint32_t *)bufr;
                             pg = pr+1;
                             pb = pg+1;
                         }
@@ -855,9 +855,9 @@ tiffToRGBImage(TiffImage * tiff, RGBImageIterator iter, RGBAccessor a)
                             TIFFReadScanline(tiff, bufr, y, 0);
                             TIFFReadScanline(tiff, bufg, y, 1);
                             TIFFReadScanline(tiff, bufb, y, 2);
-                            pr = (uint32 *)bufr;
-                            pg = (uint32 *)bufg;
-                            pb = (uint32 *)bufb;
+                            pr = (uint32_t *)bufr;
+                            pg = (uint32_t *)bufg;
+                            pb = (uint32_t *)bufb;
                         }
                                                                         
                         typename RGBImageIterator::row_iterator rowit = yd.rowIterator();
@@ -1316,7 +1316,7 @@ createBScalarTiffImage(ImageIterator upperleft, ImageIterator lowerright,
     {
         for(int y=0; y<h; ++y, ++ys.y)
         {
-            uint8 * p = (uint8 *)buf;
+            uint8_t * p = (uint8_t *)buf;
             ImageIterator xs(ys);
             
             for(int x=0; x<w; ++x, ++xs.x)
@@ -1402,7 +1402,7 @@ createUShortScalarTiffImage(ImageIterator upperleft, ImageIterator lowerright,
     {
         for(int y=0; y<h; ++y, ++ys.y)
         {
-            uint16 * p = (uint16 *)buf;
+            uint16_t * p = (uint16_t *)buf;
             ImageIterator xs(ys);
             
             for(int x=0; x<w; ++x, ++xs.x)
@@ -1745,9 +1745,9 @@ createBRGBTiffImage(RGBImageIterator upperleft, RGBImageIterator lowerright,
     {
         for(int y=0; y<h; ++y, ++ys.y)
         {
-            uint8 * pr = (uint8 *)buf;
-            uint8 * pg = pr+1;
-            uint8 * pb = pg+1;
+            uint8_t * pr = (uint8_t *)buf;
+            uint8_t * pg = pr+1;
+            uint8_t * pb = pg+1;
             
             RGBImageIterator xs(ys);
             
@@ -1793,9 +1793,9 @@ createShortRGBTiffImage(RGBImageIterator upperleft, RGBImageIterator lowerright,
     {
         for(int y=0; y<h; ++y, ++ys.y)
         {
-            uint16 * pr = (uint16 *)buf;
-            uint16 * pg = pr+1;
-            uint16 * pb = pg+1;
+            uint16_t * pr = (uint16_t *)buf;
+            uint16_t * pg = pr+1;
+            uint16_t * pb = pg+1;
             
             RGBImageIterator xs(ys);
             
@@ -1841,9 +1841,9 @@ createIRGBTiffImage(RGBImageIterator upperleft, RGBImageIterator lowerright,
     {
         for(int y=0; y<h; ++y, ++ys.y)
         {
-            uint32 * pr = (uint32 *)buf;
-            uint32 * pg = pr+1;
-            uint32 * pb = pg+1;
+            uint32_t * pr = (uint32_t *)buf;
+            uint32_t * pg = pr+1;
+            uint32_t * pb = pg+1;
             
             RGBImageIterator xs(ys);
             
diff --git a/src/impex/tiff.cxx b/src/impex/tiff.cxx
index d85c8d57c..82e8becd3 100644
--- a/src/impex/tiff.cxx
+++ b/src/impex/tiff.cxx
@@ -187,9 +187,9 @@ namespace vigra {
         tdata_t * stripbuffer;
         tstrip_t strip;
 
-        uint32 stripindex, stripheight;
-        uint32 width, height;
-        uint16 samples_per_pixel, bits_per_sample,
+        uint32_t stripindex, stripheight;
+        uint32_t width, height;
+        uint16_t samples_per_pixel, bits_per_sample,
             photometric, planarconfig, fillorder, extra_samples_per_pixel;
         float x_resolution, y_resolution;
         Diff2D position;
@@ -276,7 +276,7 @@ namespace vigra {
 
     std::string TIFFDecoderImpl::get_pixeltype_by_sampleformat() const
     {
-        uint16 sampleformat;
+        uint16_t sampleformat;
 
         if ( TIFFGetField( tiff, TIFFTAG_SAMPLEFORMAT, &sampleformat ) ) {
 
@@ -320,7 +320,7 @@ namespace vigra {
 
     std::string TIFFDecoderImpl::get_pixeltype_by_datatype() const
     {
-        uint16 datatype;
+        uint16_t datatype;
 
         if ( TIFFGetField( tiff, TIFFTAG_DATATYPE, &datatype ) ) {
             // dangelo: correct parsing of INT/UINT (given in tiff.h)
@@ -361,7 +361,7 @@ namespace vigra {
         TIFFGetField( tiff, TIFFTAG_IMAGELENGTH, &height );
 
         // check for tiled TIFFs
-        uint32 tileWidth, tileHeight;
+        uint32_t tileWidth, tileHeight;
         if( TIFFGetField( tiff, TIFFTAG_TILEWIDTH, &tileWidth ) &&
             TIFFGetField( tiff, TIFFTAG_TILELENGTH, &tileHeight ) )
             vigra_precondition( (tileWidth == width) && (tileHeight == height),
@@ -380,7 +380,7 @@ namespace vigra {
                         " A suitable default was not found." );
 
         // read extra samples (# of alpha channels)
-        uint16 *extra_sample_types=0;
+        uint16_t *extra_sample_types=0;
         if (TIFFGetField( tiff, TIFFTAG_EXTRASAMPLES,
                           &extra_samples_per_pixel, &extra_sample_types )!=1)
         {
@@ -450,7 +450,7 @@ namespace vigra {
             case PHOTOMETRIC_LOGL:
             case PHOTOMETRIC_LOGLUV:
             {
-                uint16 tiffcomp;
+                uint16_t tiffcomp;
                 TIFFGetFieldDefaulted( tiff, TIFFTAG_COMPRESSION, &tiffcomp );
                 if (tiffcomp != COMPRESSION_SGILOG && tiffcomp != COMPRESSION_SGILOG24)
                     vigra_fail("TIFFDecoder:"
@@ -532,8 +532,8 @@ namespace vigra {
         }
 
         // other fields
-        uint16 u16value;
-        uint32 u32value;
+        uint16_t u16value;
+        uint32_t u32value;
         float unitLength = 1.0f;
         if (TIFFGetField( tiff, TIFFTAG_RESOLUTIONUNIT, &u16value )) {
             switch (u16value) {
@@ -579,7 +579,7 @@ namespace vigra {
             canvasSize.y = u32value;
         }
 
-        if ((uint32)canvasSize.x < position.x + width || (uint32)canvasSize.y < position.y + height)
+        if ((uint32_t)canvasSize.x < position.x + width || (uint32_t)canvasSize.y < position.y + height)
         {
             canvasSize.x = canvasSize.y = 0;
         }
@@ -956,7 +956,7 @@ namespace vigra {
         TIFFSetField( tiff, TIFFTAG_BITSPERSAMPLE, bits_per_sample );
 
        if (extra_samples_per_pixel > 0) {
-              uint16 * types = new  uint16[extra_samples_per_pixel];
+              uint16_t * types = new  uint16_t[extra_samples_per_pixel];
            for ( int i=0; i < extra_samples_per_pixel; i++ ) {
               types[i] = EXTRASAMPLE_UNASSALPHA;
             }
@@ -990,8 +990,8 @@ namespace vigra {
             TIFFSetField( tiff, TIFFTAG_YPOSITION, position.y / y_resolution);
         }
 
-        if ((uint32)canvasSize.x >= position.x + width
-            && (uint32)canvasSize.y >= position.y + height)
+        if ((uint32_t)canvasSize.x >= position.x + width
+            && (uint32_t)canvasSize.y >= position.y + height)
         {
             TIFFSetField( tiff, TIFFTAG_PIXAR_IMAGEFULLWIDTH, canvasSize.x);
             TIFFSetField( tiff, TIFFTAG_PIXAR_IMAGEFULLLENGTH, canvasSize.y);
diff --git a/test/impex/test.cxx b/test/impex/test.cxx
index 61f844abd..758aa7af9 100755
--- a/test/impex/test.cxx
+++ b/test/impex/test.cxx
@@ -241,7 +241,7 @@ class ByteImageExportImportTest
         createTiffImage(View(img), tiff);
         TIFFClose(tiff);
 
-        uint32 w, h;
+        uint32_t w, h;
         tiff = TIFFOpen("res2.tif", "r");
         TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
         TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);
@@ -525,7 +525,7 @@ class ByteRGBImageExportImportTest
         createTiffImage(MultiArrayView<2, RGBValue<unsigned char> >(img), tiff);
         TIFFClose(tiff);
 
-        uint32 w, h;
+        uint32_t w, h;
         tiff = TIFFOpen("res2.tif", "r");
         TIFFGetField(tiff, TIFFTAG_IMAGEWIDTH, &w);
         TIFFGetField(tiff, TIFFTAG_IMAGELENGTH, &h);
